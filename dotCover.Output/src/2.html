<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\Sistemas\TRSale\backend\TRSale.Domain\Helpers\CriptoHelper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Security.Cryptography;

namespace TRSale.Domain.Helpers
{
    public class CriptoHelper
    {
        static bool ByteArraysEqual(byte[] a1, byte[] a2)
        {
            if (a1.Length != a2.Length)
                return false;

            for (int i = 0; i &lt; a1.Length; i++)
                if (a1[i] != a2[i])
                    return false;

            return true;
        }

        public static string HashPassword(string password)
        {
            byte[] salt;
            byte[] buffer2;
            if (password == null)
            {
                throw new ArgumentNullException(&quot;password&quot;);
            }
            using (Rfc2898DeriveBytes bytes = new Rfc2898DeriveBytes(password, 0x10, 0x3e8))
            {
                salt = bytes.Salt;
                buffer2 = bytes.GetBytes(0x20);
            }
            byte[] dst = new byte[0x31];
            Buffer.BlockCopy(salt, 0, dst, 1, 0x10);
            Buffer.BlockCopy(buffer2, 0, dst, 0x11, 0x20);
            return Convert.ToBase64String(dst);
        }

        public static bool VerifyHashedPassword(string hashedPassword, string password)
        {
            byte[] buffer4;
            if (hashedPassword == null)
            {
                return false;
            }
            if (password == null)
            {
                throw new ArgumentNullException(&quot;password&quot;);
            }
            byte[] src = Convert.FromBase64String(hashedPassword);
            if ((src.Length != 0x31) || (src[0] != 0))
            {
                return false;
            }
            byte[] dst = new byte[0x10];
            Buffer.BlockCopy(src, 1, dst, 0, 0x10);
            byte[] buffer3 = new byte[0x20];
            Buffer.BlockCopy(src, 0x11, buffer3, 0, 0x20);

            using (Rfc2898DeriveBytes bytes = new Rfc2898DeriveBytes(password, dst, 0x3e8))
            {
                buffer4 = bytes.GetBytes(0x20);
            }
            return ByteArraysEqual(buffer3, buffer4);
        }

        public static string EncryptString(string plainText, string key, string keyIv)
        {
            int keyByteSize = 32;
            bool useHex = true;
            byte[] keyBytes = new byte[keyByteSize];
            byte[] ivBytes = new byte[16];
            byte[] cipherBytes;

            if (useHex)
            {
                int len = keyByteSize * 2;
                for (int i = 0; i &lt; len; i += 2)
                {
                    keyBytes[i / 2] = Convert.ToByte(key.Substring(i, 2), 16);
                    if (i &lt; 32)
                        ivBytes[i / 2] = Convert.ToByte(keyIv.Substring(i, 2), 16);
                }
            }
            else
            {
                keyBytes = Convert.FromBase64String(key);
                ivBytes = Convert.FromBase64String(keyIv);
            }

            using (Aes aes = Aes.Create())
            {
                aes.Key = keyBytes;
                aes.IV = ivBytes;
                ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);
                using MemoryStream memoryStream = new MemoryStream();
                using CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
                using (StreamWriter streamWriter = new StreamWriter(cryptoStream))
                {
                    streamWriter.Write(plainText);
                }
                cipherBytes = memoryStream.ToArray();
            }
            return Convert.ToBase64String(cipherBytes);
        }
        public static string DecryptString(string cipherText, string key, string keyIv)
        {
            try
            {
                int keyByteSize = 32;
                bool useHex = true;
                byte[] keyBytes = new byte[keyByteSize];
                byte[] ivBytes = new byte[16];
                byte[] cipherBytes = Convert.FromBase64String(cipherText);

                if (useHex)
                {
                    int len = keyByteSize * 2;
                    for (int i = 0; i &lt; len; i += 2)
                    {
                        keyBytes[i / 2] = Convert.ToByte(key.Substring(i, 2), 16);
                        if (i &lt; 32)
                            ivBytes[i / 2] = Convert.ToByte(keyIv.Substring(i, 2), 16);
                    }
                }
                else
                {
                    keyBytes = Convert.FromBase64String(key);
                    ivBytes = Convert.FromBase64String(keyIv);
                }

                using Aes aes = Aes.Create();
                aes.Key = keyBytes;
                aes.IV = ivBytes;
                ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);
                using MemoryStream memoryStream = new MemoryStream(cipherBytes);
                using CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
                using StreamReader streamReader = new StreamReader(cryptoStream);

                return streamReader.ReadToEnd();
            }
            catch (Exception)
            {

                return &quot;&quot;;
            }


        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[8,9,8,10,1],[9,13,9,40,1],[10,17,10,30,0],[12,18,12,27,1],[12,29,12,42,1],[12,44,12,47,1],[13,17,13,36,1],[14,21,14,34,1],[16,13,16,25,1],[17,9,17,10,1],[20,9,20,10,1],[23,13,23,34,1],[24,13,24,14,0],[25,17,25,61,0],[27,20,27,92,1],[28,13,28,14,1],[29,17,29,35,1],[30,17,30,48,1],[31,13,31,14,1],[32,13,32,41,1],[33,13,33,53,1],[34,13,34,59,1],[35,13,35,48,1],[36,9,36,10,1],[39,9,39,10,1],[41,13,41,40,1],[42,13,42,14,0],[43,17,43,30,0],[45,13,45,34,1],[46,13,46,14,0],[47,17,47,61,0],[49,13,49,67,1],[50,13,50,55,1],[51,13,51,14,0],[52,17,52,30,0],[54,13,54,41,1],[55,13,55,52,1],[56,13,56,45,1],[57,13,57,59,1],[59,20,59,91,1],[60,13,60,14,1],[61,17,61,48,1],[62,13,62,14,1],[63,13,63,54,1],[64,9,64,10,1],[67,9,67,10,1],[68,13,68,34,1],[69,13,69,32,1],[70,13,70,53,1],[71,13,71,43,1],[74,13,74,24,1],[75,13,75,14,1],[76,17,76,43,1],[77,22,77,31,1],[77,33,77,40,1],[77,42,77,48,1],[78,17,78,18,1],[79,21,79,79,1],[80,21,80,32,1],[81,25,81,84,1],[82,17,82,18,1],[83,13,83,14,1],[85,13,85,14,0],[86,17,86,58,0],[87,17,87,59,0],[88,13,88,14,0],[90,20,90,42,1],[91,13,91,14,1],[92,17,92,36,1],[93,17,93,34,1],[94,17,94,83,1],[95,17,95,70,1],[96,17,96,117,1],[97,24,97,82,1],[98,17,98,18,1],[99,21,99,51,1],[100,17,100,18,1],[101,17,101,54,1],[102,13,102,14,1],[103,13,103,56,1],[104,9,104,10,1],[106,9,106,10,1],[108,13,108,14,1],[109,17,109,38,1],[110,17,110,36,1],[111,17,111,57,1],[112,17,112,47,1],[113,17,113,75,1],[115,17,115,28,1],[116,17,116,18,1],[117,21,117,47,1],[118,26,118,35,1],[118,37,118,44,1],[118,46,118,52,1],[119,21,119,22,1],[120,25,120,83,1],[121,25,121,36,1],[122,29,122,88,1],[123,21,123,22,1],[124,17,124,18,1],[126,17,126,18,0],[127,21,127,62,0],[128,21,128,63,0],[129,17,129,18,0],[131,17,131,46,1],[132,17,132,36,1],[133,17,133,34,1],[134,17,134,83,1],[135,17,135,81,1],[136,17,136,116,1],[137,17,137,82,1],[139,17,139,49,1],[141,13,141,30,0],[142,13,142,14,0],[144,17,144,27,0],[148,9,148,10,1]]);
    </script>
  </body>
</html>